<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>N2O</title>
    <link rel="stylesheet" href="https://n2o.space/n2o.css" />
</head>

<body>

<header>
    <a href="../index.html"><img src="https://n2o.space/img/Synrc Neo.svg"></a>
    <h1>N2O API</h1>
</header>

<main>
    <section>

<h3>INTRO</h3>

<p>The <b>n2o</b> defines the way you define, confifure and run
arbitrary applications and protocols inside some hosts, into
which <b>n2o</b> is injected. They can be <b>cowboy</b> and <b>emqttd</b>.
Each application can spawn its instance in own way, like
web pages spawn WebSocket connections, workflow engines
spawn business proceseses and chat application spawns roster
and chatroom processes. This is managed by protocols.</p>

<h3>PROTOCOLS</h3>

<p>While all application protocols in the system
are desired to be placed in the single effectful
environment or same error handling path, <b>n2o</b> defines
single protocol loop for all applications in its federation of protocols.</p>

<p>In core bundle <b>n2o</b> is shipped with NITRO and FTP protocols which
allows you to create real-time web applications with binary-based protocols,
priving also robust and performant upload client and file transfer protocol.
For bulding web based NITRO applications you need to include
<b>nitro</b> dependency.</p>

<h3>CONFIG</h3>

<figure><code>
  [{n2o,[{formatter,bert},
         {json,jsone},
         {logging,n2o_io},
         {pickler,n2o_secret},
         {erroring,n2o},
         {protocols,[n2o_ftp,n2o_nitro]},
         {filter,{n2o_proto,push}},
         {timer,{0,10,0}}]}].

</code></figure>

<h3>CACHE</h3>

<p>Cache turns each ETS store into expirable. Just put values onto keys using these
functions and system timer will clear expired entries eventually. Cache is like a memcache or redis,
but you don't need a memcache or redis if you write in Erlang.</p>

<h4>cache(Tab, Key, Value, Till) -> term().</h4>

<p>Sets a Value with a given TTL.</p>

<h4>cache(Tab, Key) -> term().</h4>

<p>Gets a Value.</p>

<h3>SESSION</h3>

<p>Sessions are stored in <b>cookies</b> table and indexed by security token which
is usually a password based token. All session variables from all users are stored in this table.
each user see only its variables indexed by his token. Sessions like a cache are expirable.
Technically, N2O sessions are the server controlling mechanism of JavaScript cookies.</p>

<h4>session(Key, Value) -> term().</h4>

<p>Sets a Value into ETS table <b>cookies</b> for a token from #cx.session which
is set there earlier from INIT message or MQTT headers,
before entering the top level N2O loop.</p>

<figure><figcaption>Listing 1. </figcaption>
<code>
 1> rr(n2o).
 [bin,client,cx,direct,ev,flush,ftp,ftpack,handler,
  mqtt_client,mqtt_message,pickle,server]
 2> put(context,#cx{session=10}).
 undefined
 3> n2o:session(user,maxim).
 maxim
 4> ets:tab2list(cookies).
 [{{10,user},
   <<"/">>,
   {1504,977449,476430},
   {{2017,9,9},{20,32,29}},
   maxim}]

</code></figure>

<h4>session(Key) -> term().</h4>

<p>Gets a Value by any Key.</p>

<h3>LOG</h3>

<p>First you need specify global module in sys.config,
where functions <b>log_level</b> and <b>log_modules</b> are placed.</p>

<figure><figcaption>Listing 2. Project Settings.</figcaption>
<code>
 -define(LOGGER,      (application:get_env(n2o,logging,     n2o_io))).
 -define(LOG_MODULES, (application:get_env(n2o,log_modules, n2o))).
 -define(LOG_LEVEL,   (application:get_env(n2o,log_level,   n2o))).

</code></figure>

<p>Then implement these function in way of returning the list
modules you want to trace, and global log level for them.</p>

<figure><figcaption>Listing 3. Log Framework</figcaption>
<code>
 log_modules() -> [n2o,n2o_async,n2o_proto].
 log_level() -> info.

</code></figure>

<p>In your code you should use following trace functions
   which are the same as callback API for n2o logging
   environment variable.</p>

<h4>error(Module, Format, Args) -> ok | skip.</h4>

<h4>info(Module, Format, Args) -> ok | skip.</h4>

<h4>warning(Module, Format, Args) -> ok | skip.</h4>



<p>Also you may refer to:
<a href="http://erlang.org/doc/man/io.html">io</a></b>,
<a href="http://erlang.org/doc/man/ets.html">ets</a></b>,
<a href="n2o.htm">n2o</a></b>,
<a href="n2o_format.htm">n2o_format</a></b>,
<a href="n2o_proto.htm"><b>n2o_proto</b></a>,
<a href="n2o_async.htm"><b>n2o_async</b></a>,
<a href="n2o_ftp.htm"><b>n2o_ftp</b></a>,
<a href="n2o_nitro.htm"><b>n2o_nitro</b></a>,
</p>

    </section>
</main>

<footer>
    2017 &copy; Synrc Research Center
</footer>

</body>
</html>

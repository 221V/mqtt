<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="" />
    <meta name="author" content="Maxim Sokhatsky" />
    <title>N2O</title>
    <link rel="stylesheet" href="https://n2o.space/n2o.css" />
</head>

<body>

<header>
    <a href="../index.html"><img src="https://n2o.space/img/Synrc Neo.svg"></a>
    <h1>N2O API</h1>
</header>

<main>
    <section>

<h3>INTRO</h3>

<p>The <b>n2o</b> defines the way you define, confifure and run
arbitrary applications and protocols inside some hosts, into
which <b>n2o</b> is injected. They can be <b>cowboy</b> and <b>emqttd</b>.
Each application can spawn its instance in own way, like
web pages spawn WebSocket connections, workflow engines
spawn business proceseses and chat application spawns roster
and chatroom processes. This is managed by protocols.</p>

    </section>
    <section>

<h3>RECORDS</h3>

<figure><figcaption>Listing 1. N2O Metaprotocol</figcaption><code>
   #reply { data = [] :: [] | binary(),
            req = [] :: [] | term(),
            state = [] :: [] | term() }.

 #unknown { data = [] :: [] | binary(),
            req = [] :: [] | term(),
            state = [] :: [] | term() }.

</code></figure>

<figure><figcaption>Listing 2. N2O Context</figcaption><code>

      #cx { session=[] :: [] | binary(),
            actions=[] :: list(#),
            state=[] :: [] | term(),
            module=[] :: [] | atom(),
            lang=[] :: [] | atom(),
            path=[] :: [] | binary(),
            formatter=bert :: bert | json,
            node=[] :: [] | atom(),
            client_pid=[] :: [] | pid(),
            vsn=[] :: [] | integer() }).

</code></figure>

    </section>
    <section>

<h3>PROTOCOLS</h3>

<p>While all application protocols in the system
are desired to be placed in the single effectful
environment or same error handling path, <b>n2o</b> defines
single protocol loop for all applications in its federation of protocols.</p>

<p>In core bundle <b>n2o</b> is shipped with NITRO and FTP protocols which
allows you to create real-time web applications with binary-based protocols,
priving also robust and performant upload client and file transfer protocol.
For bulding web based NITRO applications you need to include
<b>nitro</b> dependency.</p>

<h4>info(term(),#cx{}) -> #reply{} | #unknown{}.</h4>

<p>The <b>info/2</b> is a N2O protocol callback that will be called on each
incoming request. N2O code should be embedded into applications host:
MQTT (as ring of MQTT clients), or HTTP server or WebSocket, or raw TCP.</p>

    </section>
    <section>

<h3>RPC</h3>

<p>N2O provides RPC over MQ mechanism for MQTT devices. N2O spawn a set of
vnode workers as n2o_async processes, and listen to <b>events</b> topic.
Response are sent to <b>actions</b> topic, which is subscribed automatically on MQTT session init.</p>

<figure><figcaption>Listing 3. N2O RPC Topics</figcaption><code>
 actions/:vsn/:module/:client
 events/:vsn/:node/:module/:user/:client/:token

</code></figure>

    </section>
    <section>

<h3>EXAMPLE</h3>

<p>Here is little example of overring INIT protocol message from NITRO protocol
and generate standart token stored in KVS.</p>

<figure><figcaption>Listing 4. Custom INIT Protocol</figcaption><code>
 -module(custom_init).
 -compile(export_all).

 info({init, <<>>}, Req, State = #cx{session = Session}) ->
      {'Token', Token} = n2o_auth:gen_token([], Session),
      #cx{params = Client} = get(context),
      kvs:put(#'Token'{token = Token, client = Client}),
      n2o_nitro:info({init, n2o:format(Token)}, Req, State);

 info(Message,Req,State) -> {unknown,Message,Req,State}.

</code></figure>

    </section>
    <section>

<h3>CONFIG</h3>

<p>Just put protocol implementation module name to <b>protocol</b> option in sys.config.</p>

<figure><code>
  [{n2o,[{logging,n2o_io},
         {formatter,n2o_format},
         {pickler,n2o_secret},
         {log_modules,n2o},
         {log_level,n2o},
         {protocols,[custom_init,n2o_ftp,n2o_nitro]},
         {timer,{0,10,0}}]}].

</code></figure>

    </section>
    <section>

<h3>CACHE</h3>

<p>Cache turns each ETS store into expirable. Just put values onto keys using these
functions and system timer will clear expired entries eventually. Cache is like a memcache or redis,
but you don't need a memcache or redis if you write in Erlang.</p>

<h4>cache(Tab, Key, Value, Till) -> term().</h4>

<p>Sets a Value with a given TTL.</p>

<h4>cache(Tab, Key) -> term().</h4>

<p>Gets a Value.</p>

    </section>
    <section>

<h3>SESSION</h3>

<p>Sessions are stored in <b>cookies</b> table and indexed by security token which
is usually a password based token. All session variables from all users are stored in this table.
each user see only its variables indexed by his token. Sessions like a cache are expirable.
Technically, N2O sessions are the server controlling mechanism of JavaScript cookies.</p>

<h4>session(Key, Value) -> term().</h4>

<p>Sets a Value into ETS table <b>cookies</b> for a token from #cx.session which
is set there earlier from INIT message or MQTT headers,
before entering the top level N2O loop.</p>

<figure><figcaption>Listing 1. </figcaption>
<code>
 1> rr(n2o).
 [bin,client,cx,direct,ev,flush,ftp,ftpack,handler,
  mqtt_client,mqtt_message,pickle,server]
 2> put(context,#cx{session=10}).
 undefined
 3> n2o:session(user,maxim).
 maxim
 4> ets:tab2list(cookies).
 [{{10,user},
   <<"/">>,
   {1504,977449,476430},
   {{2017,9,9},{20,32,29}},
   maxim}]

</code></figure>

<h4>session(Key) -> term().</h4>

<p>Gets a Value by any Key.</p>

    </section>
    <section>

<h3>FORMAT</h3>

<p>Call this function for changeable at runtime socket binary formatting.</p>

<h4>format(Message, bert | json) -> binary().</h4>

    </section>
    <section>

<h3>LOG</h3>

<p>First you need specify global module in sys.config,
where functions <b>log_level</b> and <b>log_modules</b> are placed.
See options in config with with same names as functions.</p>

<p>Then implement these function in way of returning the list
modules you want to trace, and global log level for them.</p>

<figure><figcaption>Listing 3. Log Framework</figcaption>
<code>
 log_modules() -> [n2o,n2o_async,n2o_proto].
 log_level() -> info.

</code></figure>

<p>In your code you should use following trace functions
   which are the same as callback API for n2o logging
   environment variable.</p>

<h4>error(Module, Format, Args) -> ok | skip.</h4>

<h4>info(Module, Format, Args) -> ok | skip.</h4>

<h4>warning(Module, Format, Args) -> ok | skip.</h4>

    </section>
    <section>

<p>Also you may refer to:
<a href="http://erlang.org/doc/man/io.html">io</a></b>,
<a href="http://erlang.org/doc/man/ets.html">ets</a></b>,
<a href="n2o.htm">n2o</a></b>,
<a href="n2o_proto.htm"><b>n2o_proto</b></a>,
<a href="n2o_async.htm"><b>n2o_async</b></a>,
<a href="n2o_async.htm"><b>n2o_vnode</b></a>.
</p>

    </section>
</main>

<footer>
    2017 &copy; Synrc Research Center
</footer>

</body>
</html>
